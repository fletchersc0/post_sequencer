<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rapid fact-checking of news</title>

  <style>
    :root {
      --bg: #000;
      --fg: #fff;
      --input-bg: #1a1a1a;
      --border-color:#444;
      --warning-color: #ff4d4d;
    }
    *      { box-sizing:border-box; }
    html,body{
      margin:0;
      font-family:system-ui,sans-serif;
      background:var(--bg);
      color:var(--fg);
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:100vh;
      text-align:center;
    }
    #stage{
      width:92%;
      max-width:860px;
      padding:2rem;
    }
    button,
    input[type=text],
    input[type=number],
    select {
      font-size:1rem;
      padding:.5rem 1rem;
      margin:.3rem;
      background:var(--input-bg);
      color:var(--fg);
      border:1px solid var(--border-color);
    }
    button{
      cursor:pointer;
      background:#222;
    }
    button:hover{
      background:#333;
      border-color:#555;
    }
    .fixation-cross-container{
      font-size:3rem;
      height:6em; 
      display:flex;align-items:center;justify-content:center;
    }
    .stimulus-container, .message-container, .questionnaire-container, .info-container {
      min-height:12em; 
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      padding: 1em;
    }
    .info-container {
      text-align: left;
      max-width: 680px;
      margin: auto;
      line-height: 1.6;
    }
    .info-container h2 { text-align: center; }
    .info-container .button-container {
      text-align: center;
      width: 100%;
      margin-top: 2em;
    }
    .stimulus-text { 
      font-size: 1.8rem; 
      line-height: 1.4;
      margin-bottom: 1em;
      max-width: 90%; 
    }
    .instructions-text, .message-text, .question-text { 
      font-size:1.1rem; 
      line-height:1.6; 
      margin-bottom:1em;
    }
    .key-reminder { 
      font-size:1rem; 
      color: #ccc; 
      margin-top: 1em;
      width: 100%;
      overflow: hidden;
    }
    .loading, .error-text { font-size:1.2rem; color: #aaa; }
    .input-label { display: block; margin-top: 1em; margin-bottom: 0.2em; }
    .warning-message {
      color: var(--warning-color);
      font-weight: bold;
      font-size: 1.2rem;
      margin: 1em 0;
    }
    #countdown {
      font-weight: bold;
      font-size: 1.2rem;
      color: var(--warning-color);
      margin-top: 1em;
    }
    .completion-arrow {
      font-size: 2rem;
      padding: 1rem 2rem;
      margin-top: 1.5rem;
      cursor: pointer;
      background: #2a2a2a;
      border: 1px solid #555;
      border-radius: 8px;
      transition: all 0.3s;
    }
    .completion-arrow:hover {
      background: #3a3a3a;
      transform: translateX(5px);
    }
    /* Slider styles for political orientation questions */
    .slider-container {
      width: 100%;
      max-width: 480px;
      margin: 1em auto;
    }
    .slider-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
      margin-top: 0.5em;
    }
    input[type=range] {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 5px;
      background: #444;
      outline: none;
      opacity: 0.7;
      -webkit-transition: .2s;
      transition: opacity .2s;
      margin: 1em 0;
    }
    input[type=range]:hover { opacity: 1; }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #0866ff;
      cursor: pointer;
    }
    input[type=range]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #0866ff;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="stage">Loading experiment...</div>

<script>
// -------------------- CONFIG --------------------
// Current Date and Time (UTC - YYYY-MM-DD HH:MM:SS formatted): 2025-07-09 06:32:43
// Current User's Login: fletchersc0

const CONFIG = {
  experimentName         : 'Rapid fact-checking of news',
  csvFile                : 'stimulus_master.csv', 
  // Response keys will be assigned randomly at startup
  responseKeys           : { 
    true_key: null,  // Will be assigned 'q' or 'p' 
    false_key: null, // Will be assigned the other key
  },
  dataPipeID             : 'qWHxwr6D720q', 
  fallbackDownload       : true, 
  
  // Moderate range definition for political orientation
  moderateRange          : { min: 40, max: 60 }, // Values between 40-60 are considered moderate
  
  fixationCrossDuration  : 500,
  statementTimeoutDuration: 15000,
  itiMinDuration         : 500,
  itiMaxDuration         : 1000,
  
  numPracticeTrials      : 4,
  trialsPerBreak         : 16, // Break every 16 statements (reasonable for 64 total)

  // headline types, truthValues, congruenceLevels for structure definition
  headlineTypes          : ['Clickbait', 'Not Clickbait'],
  truthValues            : ['True', 'False'], 
  congruenceLevels       : ['Congruent', 'Incongruent'],

  // Prolific completion URL
  prolificCompletionURL  : 'https://app.prolific.com/submissions/complete?cc=C48PGS7A',

  // Predefined practice trials - obvious facts and myths
  practiceTrials         : [
    {
      statement_id: 'practice_fact_1',
      statement_text: 'The American flag has 50 stars, one for each U.S. state.',
      headline_type: 'Not Clickbait',
      truth_value: true,
      partisan_alignment: 'Neutral',
      is_practice_stimulus: true,
      is_attention_check: false,
      partisan_congruence: 'Neutral'
    },
    {
      statement_id: 'practice_fact_2',
      statement_text: 'Humans need oxygen to survive.',
      headline_type: 'Not Clickbait',
      truth_value: true,
      partisan_alignment: 'Neutral',
      is_practice_stimulus: true,
      is_attention_check: false,
      partisan_congruence: 'Neutral'
    },
    {
      statement_id: 'practice_myth_1',
      statement_text: 'The Sun revolves around the Earth each day.',
      headline_type: 'Clickbait',
      truth_value: false,
      partisan_alignment: 'Neutral',
      is_practice_stimulus: true,
      is_attention_check: false,
      partisan_congruence: 'Neutral'
    },
    {
      statement_id: 'practice_myth_2',
      statement_text: 'New York City is the capital of the United States.',
      headline_type: 'Clickbait',
      truth_value: false,
      partisan_alignment: 'Neutral',
      is_practice_stimulus: true,
      is_attention_check: false,
      partisan_congruence: 'Neutral'
    }
  ],

  masterHeader : [ 
    'prolific_id', 'political_orientation', 'participant_headline_type', 'key_assignment',
    'trial_number_overall', 'block_type', 'trial_number_in_block',
    'statement_id', 'statement_text', 
    'headline_type', 'truth_value_stimulus', 'partisan_alignment_stimulus', 'partisan_congruence',
    'is_practice_trial', 'is_attention_check',
    'response', 'accuracy', 'rt_ms',
    'avg_favorability', // Added new column for data export
    'age', 'gender', 'education', // Added demographic variables
    'partisanship_q1', 'partisanship_q2', 'partisanship_q3', 'partisanship_q4', 'partisanship_q5', 'partisanship_q6_orientation', // Added political orientation questions
    'is_moderate', 'congruence_assignment_basis', // Added fields for tracking moderate status and assignment basis
    'timestamp'
  ]
};

// ------------------------ STATE OBJECT ------------------------
const state = {
  prolificID              : '',
  politicalOrientation    : '',
  participantHeadlineType : '', // Will be randomly assigned after demographics
  keyAssignment           : '', // Will store which key is assigned to "true"
  
  // Added demographic variables to state
  age                     : null,
  gender                  : '',
  education               : '',
  
  // Added political orientation questionnaire variables
  partisanship_q1         : null,
  partisanship_q2         : null,
  partisanship_q3         : null,
  partisanship_q4         : null,
  partisanship_q5         : null,
  partisanship_q6_orientation : null,
  
  // Added moderate tracking
  isModerate              : false,
  congruenceAssignmentBasis : '', // Will record how congruence was determined (direct, random)
  moderateCongruenceDirection : null, // For moderates: randomly assigned direction for congruence (Left/Right)
  
  allStimuli              : [], 
  practiceStimuli         : [], 
  mainExperimentStimuli   : [],
  data                    : [],
  trialCountOverall       : 0,
  currentBlock            : '',
  currentTrialInBlock     : 0,
  totalMainTrials         : 0,
};

const stage = document.getElementById('stage');
let rtClock = 0;

// Randomize response key assignment at startup
function assignResponseKeys() {
  // Randomly decide if 'q' means true (50% chance)
  const qIsTrue = Math.random() < 0.5;
  
  if (qIsTrue) {
    CONFIG.responseKeys.true_key = 'q';
    CONFIG.responseKeys.false_key = 'p';
    state.keyAssignment = 'q=true_p=false';
  } else {
    CONFIG.responseKeys.true_key = 'p';
    CONFIG.responseKeys.false_key = 'q';
    state.keyAssignment = 'p=true_q=false';
  }
  
  console.log(`Key assignment: TRUE=${CONFIG.responseKeys.true_key}, FALSE=${CONFIG.responseKeys.false_key}`);
}

// Call this immediately to set up the key assignment
assignResponseKeys();

// ------------------------ UTILITY FUNCTIONS ------------------------
const sleep = ms => new Promise(r => setTimeout(r, ms));
const shuffle = arr => { for(let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; };
const show = html => stage.innerHTML = html;
const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

// Key reminder helper function that maintains spatial layout
function getKeyReminderHTML() {
  return `<p class="key-reminder">
    <span style="float:left; width:45%; text-align:left;">Q = ${CONFIG.responseKeys.true_key === 'q' ? 'TRUE' : 'FALSE'}</span>
    <span style="float:right; width:45%; text-align:right;">P = ${CONFIG.responseKeys.true_key === 'p' ? 'TRUE' : 'FALSE'}</span>
  </p>`;
}

// ------------------------ DATA LOGGING FUNCTIONS ------------------------
function log(dataRow) {
  dataRow.timestamp = new Date().toISOString();
  // Add key assignment to every row
  dataRow.key_assignment = state.keyAssignment;
  
  // Add demographic data to every row
  dataRow.age = state.age;
  dataRow.gender = state.gender;
  dataRow.education = state.education;
  
  // Add political orientation questionnaire data to every row
  dataRow.partisanship_q1 = state.partisanship_q1;
  dataRow.partisanship_q2 = state.partisanship_q2;
  dataRow.partisanship_q3 = state.partisanship_q3;
  dataRow.partisanship_q4 = state.partisanship_q4;
  dataRow.partisanship_q5 = state.partisanship_q5;
  dataRow.partisanship_q6_orientation = state.partisanship_q6_orientation;
  
  // Add moderate status tracking
  dataRow.is_moderate = state.isModerate ? 1 : 0;
  dataRow.congruence_assignment_basis = state.congruenceAssignmentBasis;
  
  const completeRow = {};
  CONFIG.masterHeader.forEach(header => {
    completeRow[header] = (header in dataRow) ? dataRow[header] : '';
  });
  state.data.push(completeRow);
}

// FIXED: Modified toCSV function to handle cell formatting more consistently
function toCSV(rows){
  if (!rows.length) return '';
  const header = CONFIG.masterHeader;
  const lines  = [header.join(',')];
  rows.forEach(r => {
    const line = header.map(k => {
      let cell = (k in r && r[k] !== null && r[k] !== undefined) ? r[k] : '';
      cell = String(cell); // Removed trim() to match working version
      if (/[",\n\r]/.test(cell)) cell = '"' + cell.replace(/"/g, '""') + '"';
      return cell;
    }).join(',');
    lines.push(line);
  });
  return lines.join('\n');
}

// FIXED: Updated uploadCSV function with correct URL (no trailing slash)
function uploadCSV(filename, csvData){
  if (!CONFIG.dataPipeID || CONFIG.dataPipeID === 'YOUR_JSPSYCH_DATAPIPE_ID') {
      console.warn("DataPipeID not set or is placeholder. Skipping upload.");
      return Promise.resolve({ok: false, statusText: "DataPipeID not set"});
  }
  
  console.log("Attempting to upload data to datapipe:", CONFIG.dataPipeID);
  console.log("Filename:", filename);
  console.log("Data size (bytes):", new Blob([csvData]).size);
  
  // FIXED: Removed trailing slash from API URL
  return fetch('https://pipe.jspsych.org/api/data', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ 
      experimentID: CONFIG.dataPipeID, 
      filename: filename, 
      data: csvData 
    })
  });
}

function downloadCSV(csvData, filename){
  const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ------------------- INFORMATION & CONSENT SCREEN -------------------
async function showInformationAndConsent() {
  // Default information text - replace with your own participant information
  const participantInfoHTML = `
    <h2>Participant Information Sheet</h2>
    <p>You are invited to take part in a research study about how people judge the truthfulness of different types of headlines.</p>
    
    <h3>What is the purpose of the study?</h3>
    <p>This study aims to understand how people determine whether news headlines are true or false, and how different presentation styles might influence these judgments.</p>
    
    <h3>What will I be asked to do?</h3>
    <p>You will be shown a series of headlines and asked to judge whether each one is true or false as quickly and accurately as possible. The task will take approximately 15-20 minutes to complete.</p>
    
    <h3>Risks and benefits</h3>
    <p>There are no known risks associated with this study. Your participation will help advance our understanding of how people evaluate information.</p>
    
    <h3>Data protection and confidentiality</h3>
    <p>Your responses will be kept completely anonymous. We will collect your Prolific ID only for payment purposes. Your demographic information will not be linked to your identity.</p>
    
    <h3>Ethics approval</h3>
    <p>This study has received ethical approval from [University Name] Ethics Committee.</p>
    
    <h3>Contact information</h3>
    <p>If you have any questions about this research, please contact: [Researcher Email]</p>
  `;
  
  // Try to load external information text file if available, otherwise use default
  try {
    const response = await fetch('participant_information.txt');
    if (response.ok) {
      const infoHtml = await response.text();
      show(`
        <div class="info-container">
            ${infoHtml}
            <div class="button-container">
                <a href="PIS.pdf" download="PIS.pdf" target="_blank" rel="noopener noreferrer" style="text-decoration: none;"><button>Download Information Sheet (PDF)</button></a>
                <button id="next_btn">Next</button>
            </div>
        </div>
      `);
    } else {
      // Use default information if file not found
      show(`
        <div class="info-container">
            ${participantInfoHTML}
            <div class="button-container">
                <button id="next_btn">Next</button>
            </div>
        </div>
      `);
    }
  } catch (e) {
    // Use default information if there's an error
    console.error('Failed to load participant information file:', e);
    show(`
      <div class="info-container">
          ${participantInfoHTML}
          <div class="button-container">
              <button id="next_btn">Next</button>
          </div>
      </div>
    `);
  }

  await new Promise(resolve => { document.getElementById('next_btn').onclick = resolve; });

  // Function to show rejection message when participant is not eligible or does not consent
  // MODIFIED: Updated to include countdown and redirect to Prolific
  const showRejectionMessage = () => {
    show(`
      <div class="questionnaire-container">
        <p>Thank you for your interest. As you do not meet the eligibility criteria or do not wish to consent, you cannot proceed with the study.</p>
        <p>Please return your submission on the Prolific website. You may now close this window.</p>
        <p id="countdown">Redirecting to Prolific in 5 seconds...</p>
      </div>
    `);
    
    // Start countdown and redirect after 5 seconds
    let secondsLeft = 5;
    const countdownElement = document.getElementById('countdown');
    
    const countdownInterval = setInterval(() => {
      secondsLeft--;
      if (secondsLeft <= 0) {
        clearInterval(countdownInterval);
        window.location.href = 'https://app.prolific.com';
      } else {
        countdownElement.textContent = `Redirecting to Prolific in ${secondsLeft} seconds...`;
      }
    }, 1000);
  };

  // Age verification
  show(`
    <div class="questionnaire-container">
      <p class="question-text">Are you over 18 years of age?</p>
      <button id="yes_btn">Yes</button> <button id="no_btn">No</button>
    </div>
  `);
  
  const isOver18 = await new Promise(resolve => {
    document.getElementById('yes_btn').onclick = () => resolve(true);
    document.getElementById('no_btn').onclick = () => resolve(false);
  });

  if (!isOver18) {
    showRejectionMessage();
    return false;
  }

  // Consent confirmation
  show(`
    <div class="questionnaire-container">
      <p class="question-text">Do you consent to participate in the study?</p>
      <button id="yes_btn">Yes</button> <button id="no_btn">No</button>
    </div>
  `);
  
  const hasConsented = await new Promise(resolve => {
    document.getElementById('yes_btn').onclick = () => resolve(true);
    document.getElementById('no_btn').onclick = () => resolve(false);
  });

  if (!hasConsented) {
    showRejectionMessage();
    return false;
  }

  return true; // Consent given
}

// ------------------- STIMULUS LOADER (MODIFIED TO INCLUDE AVG_FAVORABILITY) -------------------
async function loadCSVStimuli(){
  const response = await fetch(CONFIG.csvFile);
  if (!response.ok) throw new Error(`Failed to load ${CONFIG.csvFile}: ${response.statusText}`);
  const txt = await response.text();
  let lines = txt.trim().split(/\r?\n/);
  
  let delimiter = ",";
  if (lines.length > 0 && lines[0].includes("\t") && lines[0].split("\t").length > lines[0].split(",").length) {
      delimiter = "\t";
  }

  const headerLine = lines.shift();
  const header = headerLine.split(delimiter).map(h => h.trim().replace(/^"|"$/g, '').toLowerCase());
  
  // Log the actual headers found for debugging
  console.log("CSV Headers found:", header);

  // Updated expected CSV headers including avg_favorability
  const expectedCsvHeaders = ['item', 'claim', 'clickbait', 'veracity', 'favorability'];
  for (const reqHeader of expectedCsvHeaders) {
      if (!header.includes(reqHeader)) {
          throw new Error(`CSV file is missing required header: '${reqHeader}'. Found headers: ${header.join(', ')}`);
      }
  }
  
  lines.forEach((line, index) => {
    if (line.trim() === "") return; 

    let fields = [];
    if (delimiter === ",") {
        let current = '', inQuotes = false;
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"' && (i === 0 || line[i-1] !== '\\')) { 
                inQuotes = !inQuotes;
            } else if (char === delimiter && !inQuotes) {
                fields.push(current.trim().replace(/^"|"$/g, '')); current = '';
            } else {
                current += char;
            }
        }
        fields.push(current.trim().replace(/^"|"$/g, ''));
    } else { 
        fields = line.split(delimiter).map(f => f.trim().replace(/^"|"$/g, ''));
    }

    const rawStim = {};
    header.forEach((h, i) => rawStim[h] = (fields[i] !== undefined ? fields[i] : '').trim());

    const itemNum = rawStim.item;
    if (!itemNum) {
        console.warn(`Skipping CSV row ${index + 2} due to missing 'Item' number.`);
        return;
    }

    const truthValue = rawStim.veracity.toUpperCase() === 'TRUE';
    let partisanAlignment;
    if (rawStim.favorability.toLowerCase() === 'republican') {
        partisanAlignment = 'Right';
    } else if (rawStim.favorability.toLowerCase() === 'democrat') {
        partisanAlignment = 'Left';
    } else {
        console.warn(`Unknown favorability '${rawStim.favorability}' for Item ${itemNum}. Defaulting to Neutral/Undefined.`);
        partisanAlignment = 'Neutral'; 
    }

    // Capture avg_favorability if it exists in the CSV
    const avgFavorability = rawStim.avg_favorability || '';

    // Process both clickbait and non-clickbait versions
    // For clickbait version
    if (rawStim.clickbait) {
        state.allStimuli.push({
            statement_id: `item${itemNum}_clickbait`,
            statement_text: rawStim.clickbait,
            headline_type: 'Clickbait', 
            truth_value: truthValue,
            partisan_alignment: partisanAlignment,
            avg_favorability: avgFavorability, // Store avg_favorability
            is_practice_stimulus: false, 
            is_attention_check: false,   
        });
    } else {
        console.warn(`Missing 'clickbait' statement for Item ${itemNum}.`);
    }
    
    // For non-clickbait version (using claim)
    if (rawStim.claim) {
        state.allStimuli.push({
            statement_id: `item${itemNum}_notclickbait`,
            statement_text: rawStim.claim,
            headline_type: 'Not Clickbait', 
            truth_value: truthValue,
            partisan_alignment: partisanAlignment,
            avg_favorability: avgFavorability, // Store avg_favorability
            is_practice_stimulus: false, 
            is_attention_check: false,   
        });
    } else {
        console.warn(`Missing 'claim' statement for Item ${itemNum}.`);
    }
  });
  
  // Log the total number of stimuli loaded
  console.log(`Total stimuli loaded: ${state.allStimuli.length}`);
}

// ------------------- KEYBOARD HELPERS (MODIFIED FOR Q/P KEYS) -------------------
function waitKeys(validKeys) {
  return new Promise(resolve => {
    function onKey(e) {
      const key = e.key.toLowerCase();
      if (validKeys.includes(key)) {
        document.removeEventListener('keydown', onKey);
        resolve(key);
      }
    }
    document.addEventListener('keydown', onKey);
  });
}

function waitKeysOrTimeout(validKeys, timeoutMs) {
  return new Promise(resolve => {
    let timeoutId = null;
    function onKey(e) {
      const key = e.key.toLowerCase();
      if (validKeys.includes(key)) {
        if (timeoutId) clearTimeout(timeoutId);
        document.removeEventListener('keydown', onKey);
        resolve({ key: key, timedOut: false });
      }
    }
    document.addEventListener('keydown', onKey);
    timeoutId = setTimeout(() => {
      document.removeEventListener('keydown', onKey);
      resolve({ key: null, timedOut: true });
    }, timeoutMs);
  });
}

// ------------------- STIMULUS PREPARATION (MODIFIED TO HANDLE MODERATES) -------------------
function prepareExperimentTrials() {
    if (state.allStimuli.length === 0) {
        throw new Error("No stimuli loaded. Cannot prepare trials.");
    }
    if (!state.participantHeadlineType) {
        throw new Error("Headline type not assigned. Cannot prepare trials.");
    }
    
    // 1. Use predefined practice trials
    state.practiceStimuli = [...CONFIG.practiceTrials];
    shuffle(state.practiceStimuli);
    
    // 2. Filter by participant's assigned headline type (but include ALL statements of that type)
    const headlineTypeFilteredStimuli = state.allStimuli.filter(
        stim => stim.headline_type === state.participantHeadlineType
    );
    
    if (headlineTypeFilteredStimuli.length === 0) {
        throw new Error(`No stimuli found for the assigned headline type: '${state.participantHeadlineType}'. Check CSV content and distribution.`);
    }
    
    // 3. Assign Congruence for all stimuli based on participant's political orientation
    state.mainExperimentStimuli = [];
    
    headlineTypeFilteredStimuli.forEach(stim => {
        let congruence;
        
        // Handle congruence differently based on moderate status
        if (stim.partisan_alignment === 'Neutral' || !stim.partisan_alignment) { 
            // For neutral stimuli, random assignment regardless of participant orientation
            congruence = Math.random() < 0.5 ? 'Congruent' : 'Incongruent'; 
        } else if (state.isModerate) {
            // For moderates, use the randomly pre-assigned direction for congruence
            if (state.moderateCongruenceDirection === 'Left') {
                congruence = stim.partisan_alignment === 'Left' ? 'Congruent' : 'Incongruent';
            } else { // Right
                congruence = stim.partisan_alignment === 'Right' ? 'Congruent' : 'Incongruent';
            }
        } else if (state.politicalOrientation === 'Left-leaning') {
            congruence = stim.partisan_alignment === 'Left' ? 'Congruent' : 'Incongruent';
        } else if (state.politicalOrientation === 'Right-leaning') {
            congruence = stim.partisan_alignment === 'Right' ? 'Congruent' : 'Incongruent';
        } else {
            congruence = 'ErrorCongruence'; 
        }
        
        // Add all stimuli of the assigned headline type to main experiment with congruence assigned
        state.mainExperimentStimuli.push({...stim, partisan_congruence: congruence});
    });
    
    // 4. Shuffle all stimuli for random presentation order
    shuffle(state.mainExperimentStimuli);
    
    // Store total main trials count
    state.totalMainTrials = state.mainExperimentStimuli.length;
    console.log(`Prepared ${state.totalMainTrials} main trials for headline type: ${state.participantHeadlineType}`);
    
    // Log congruence assignment basis for debugging
    console.log(`Congruence assigned based on: ${state.congruenceAssignmentBasis}`);
    if (state.isModerate) {
        console.log(`Moderate participant assigned ${state.moderateCongruenceDirection}-leaning for congruence purposes`);
    }
}

// ------------------- INTRO SCREEN (MODIFIED TO CONTINUE TO DEMOGRAPHICS) -------------------
async function introScreen(){
  show(`
    <div class="message-container">
      <h1>${CONFIG.experimentName}</h1>      
      <label class="input-label" for="prolificID">Please enter your Prolific ID:</label>
      <input type="text" id="prolificID" placeholder="Prolific ID" />
      
      <br><br>
      <button id="startBtn">Continue</button>
    </div>
  `);

  return new Promise(resolve => {
    document.getElementById('startBtn').onclick = () => {
      const pid = document.getElementById('prolificID').value.trim();

      if (!pid) { alert('Please enter your Prolific ID.'); return; }
      
      state.prolificID = pid;
      resolve();
    };
  });
}

// ------------------- DEMOGRAPHICS SCREEN (UPDATED WITH POLITICAL ORIENTATION QUESTIONNAIRE) -------------------
async function runDemographics() {
  // 1. Age question
  show(`
    <div class="questionnaire-container">
      <p class="question-text">Please enter your age:</p>
      <input type="number" id="age_input" min="18" max="120" placeholder="Age" />
      <button id="next_btn">Next</button>
    </div>
  `);
  
  await new Promise(resolve => {
    document.getElementById('next_btn').onclick = () => {
      const ageInput = document.getElementById('age_input').value.trim();
      const age = parseInt(ageInput);
      
      if (!ageInput || isNaN(age) || age < 18 || age > 120) {
        alert('Please enter a valid age between 18 and 120.');
        return;
      }
      
      state.age = age;
      resolve();
    };
  });
  
  // 2. Gender question
  show(`
    <div class="questionnaire-container">
      <p class="question-text">Please select your gender:</p>
      <select id="gender_select">
        <option value="" disabled selected>Select an option</option>
        <option value="male">Male</option>
        <option value="female">Female</option>
        <option value="non-binary">Non-binary/third gender</option>
        <option value="prefer-not-to-say">Prefer not to say</option>
        <option value="other">Other</option>
      </select>
      <input type="text" id="gender_other" style="display:none;" placeholder="Please specify" />
      <button id="next_btn">Next</button>
    </div>
  `);
  
  // Show/hide the "other" text field based on selection
  document.getElementById('gender_select').addEventListener('change', function() {
    const otherField = document.getElementById('gender_other');
    otherField.style.display = this.value === 'other' ? 'block' : 'none';
  });
  
  await new Promise(resolve => {
    document.getElementById('next_btn').onclick = () => {
      const genderSelect = document.getElementById('gender_select');
      const genderOther = document.getElementById('gender_other');
      const selectedValue = genderSelect.value;
      
      if (!selectedValue) {
        alert('Please select your gender.');
        return;
      }
      
      if (selectedValue === 'other' && !genderOther.value.trim()) {
        alert('Please specify your gender.');
        return;
      }
      
      state.gender = selectedValue === 'other' ? `other: ${genderOther.value.trim()}` : selectedValue;
      resolve();
    };
  });
  
  // 3. Education question
  show(`
    <div class="questionnaire-container">
      <p class="question-text">What is your highest level of education?</p>
      <select id="education_select">
        <option value="" disabled selected>Select an option</option>
        <option value="no-highschool">Did not complete highschool</option>
        <option value="highschool">Year 12 or equivalent</option>
        <option value="diploma">Diploma or equivalent</option>
        <option value="bachelors">Bachelor's degree or equivalent</option>
        <option value="postgrad">Post-graduate degree or equivalent (e.g., Master's or PhD)</option>
      </select>
      <button id="next_btn">Next</button>
    </div>
  `);
  
  await new Promise(resolve => {
    document.getElementById('next_btn').onclick = () => {
      const educationSelect = document.getElementById('education_select');
      const selectedValue = educationSelect.value;
      
      if (!selectedValue) {
        alert('Please select your education level.');
        return;
      }
      
      state.education = selectedValue;
      resolve();
    };
  });
  
  // 4. Political Orientation Questionnaire (5 questions + direct orientation)
  // Define the five political alignment questions
  const partisanshipQuestions = [
    { id: 'partisanship_q1', text: 'I am politically more in line with the Democrat party than the Republican party.' },
    { id: 'partisanship_q2', text: 'In any election, given a choice between a Republican and a Democrat candidate, I will select the Republican over the Democrat candidate.' },
    { id: 'partisanship_q3', text: 'I cannot see myself ever voting to elect Republican candidates.' },
    { id: 'partisanship_q4', text: 'The major national media are too protective of the Democrat party for my taste.' },
    { id: 'partisanship_q5', text: 'On balance, I lean politically more to the left (Democrat) than to the right (Republican).' }
  ];

  // First present the five political alignment questions
  for (const q of partisanshipQuestions) {
    show(`
      <div class="questionnaire-container">
        <p class="question-text">${q.text}</p>
        <div class="slider-container">
          <input type="range" id="q_slider" min="0" max="100" value="50">
          <div class="slider-labels">
            <span>Strongly Disagree</span>
            <span>Strongly Agree</span>
          </div>
        </div>
        <button id="q_next">Next</button>
      </div>
    `);
    
    await new Promise(resolve => {
      document.getElementById('q_next').onclick = () => {
        state[q.id] = document.getElementById('q_slider').value;
        resolve();
      };
    });
  }

  // Then present the direct political orientation question
  show(`
    <div class="questionnaire-container">
      <p class="question-text">Using the slider below, please indicate your political orientation.</p>
      <div class="slider-container">
        <input type="range" id="q_slider" min="0" max="100" value="50">
        <div class="slider-labels">
          <span>Lean Democrat</span>
          <span>Lean Republican</span>
        </div>
      </div>
      <button id="q_next">Next</button>
    </div>
  `);
  
  await new Promise(resolve => {
    document.getElementById('q_next').onclick = () => {
      const val = parseInt(document.getElementById('q_slider').value, 10);
      state.partisanship_q6_orientation = val;
      
      // Determine political orientation based on the slider value
      // Check if in moderate range
      if (val >= CONFIG.moderateRange.min && val <= CONFIG.moderateRange.max) {
        state.isModerate = true;
        state.politicalOrientation = 'Moderate';
        
        // For moderates, randomly assign a direction for congruence purposes
        state.moderateCongruenceDirection = Math.random() < 0.5 ? 'Left' : 'Right';
        state.congruenceAssignmentBasis = 'random_assignment_for_moderate';
        
        console.log(`Moderate participant (${val}) - randomly assigned ${state.moderateCongruenceDirection} direction for congruence`);
      } else if (val < 50) {
        state.isModerate = false;
        state.politicalOrientation = 'Left-leaning';
        state.congruenceAssignmentBasis = 'direct_left_orientation';
      } else {
        state.isModerate = false;
        state.politicalOrientation = 'Right-leaning';
        state.congruenceAssignmentBasis = 'direct_right_orientation';
      }
      
      resolve();
    };
  });
  
  // After demographics, randomly assign participant to a headline type condition
  state.participantHeadlineType = Math.random() < 0.5 ? 'Clickbait' : 'Not Clickbait';
  console.log(`Participant randomly assigned to headline type: ${state.participantHeadlineType}`);
}

// ------------------- INSTRUCTIONS SCREEN (UPDATED TO BE GENERIC WITHOUT REVEALING HEADLINE TYPE) -------------------
async function showInstructionsScreen() {
    show(`
        <div class="message-container">
            <h2>Instructions</h2>
            <p class="instructions-text">
                Welcome to this session. Please turn off your phone.
                <br><br>
                Please read the following instructions carefully.
                <br><br>
                Throughout the task you will use your keyboard to respond. On each trial you will see <strong>one news claim</strong>. Some claims are accurate and others are not.
                <br><br>
                Your task:</strong> press the key that corresponds to whether you believe the claim is <em>True</em> or <em>False</em>. Answer as <strong>quickly</strong> and as <strong>accurately</strong> as possible. Once an entry has been made, it is no longer possible to re-enter.
                <br><br>
                Respond using the Q and P keys:
                <br><br>
                ${getKeyReminderHTML()}
                You will have 15 seconds to respond to each statement.
                <br><br>
                We will do a practice round first.
            </p>
            <button id="startPracticeBtn">Continue to practice</button>
        </div>
    `);
    return new Promise(resolve => {
        document.getElementById('startPracticeBtn').onclick = resolve;
    });
}

// ------------------- CORE TRIAL LOGIC (MODIFIED WITH CONSISTENT KEY REMINDER) -------------------
async function runSingleTrial(stimulus, isPracticeTrial = false) {
  state.trialCountOverall++;
  state.currentTrialInBlock++;

  // 1. Fixation Cross
  show(`<div class="fixation-cross-container">+</div>`);
  await sleep(CONFIG.fixationCrossDuration);

  // 2. Statement Display with updated key reminder (no progress tracking)
  show(`
    <div class="stimulus-container">
      <p class="stimulus-text">${stimulus.statement_text}</p> 
      ${getKeyReminderHTML()}
    </div>
  `);
  
  rtClock = performance.now();

  // 3. Get Response (now using q and p keys)
  const responseResult = await waitKeysOrTimeout([CONFIG.responseKeys.true_key, CONFIG.responseKeys.false_key], CONFIG.statementTimeoutDuration);
  const rt = responseResult.timedOut ? CONFIG.statementTimeoutDuration : Math.round(performance.now() - rtClock);
  
  let participantResponse = null;
  let accuracy = null;

  if (responseResult.timedOut) {
    participantResponse = 'TIMEOUT';
    accuracy = null; 
    
    // Show timeout warning message for both practice and main trials
    show(`
      <div class="message-container">
        <h3 class="warning-message">Time's Up!</h3>
        <p>Please try to respond more quickly. You have 15 seconds to make your judgment.</p>
        <p>Remember:</p>
        ${getKeyReminderHTML()}
        <p>Press SPACE to continue.</p>
      </div>
    `);
    await waitKeys([' ']);
  } else {
    // Determine which response was given based on the key assignment
    participantResponse = responseResult.key === CONFIG.responseKeys.true_key ? 'True' : 'False';
    accuracy = (participantResponse === 'True') === stimulus.truth_value ? 1 : 0;
  }

  // 4. Log Data (now with key assignment and avg_favorability)
  const trialData = {
    prolific_id: state.prolificID,
    political_orientation: state.politicalOrientation,
    participant_headline_type: state.participantHeadlineType,
    key_assignment: state.keyAssignment, // Record which key was assigned to which response
    trial_number_overall: state.trialCountOverall,
    block_type: state.currentBlock,
    trial_number_in_block: state.currentTrialInBlock,
    statement_id: stimulus.statement_id,
    statement_text: stimulus.statement_text, 
    headline_type: isPracticeTrial ? 'Practice' : stimulus.headline_type,
    truth_value_stimulus: stimulus.truth_value ? 'TRUE' : 'FALSE', 
    partisan_alignment_stimulus: stimulus.partisan_alignment,
    partisan_congruence: stimulus.partisan_congruence || 'N/A', 
    is_practice_trial: isPracticeTrial ? 1 : 0,
    is_attention_check: stimulus.is_attention_check ? 1 : 0, 
    response: participantResponse,
    accuracy: accuracy,
    rt_ms: rt,
    avg_favorability: stimulus.avg_favorability || '', // Include avg_favorability from stimulus
  };
  log(trialData);

  // 5. Inter-Trial Interval (ITI)
  show(''); 
  const itiDuration = getRandomInt(CONFIG.itiMinDuration, CONFIG.itiMaxDuration);
  await sleep(itiDuration);
}

// ------------------- BLOCKS & EXPERIMENT FLOW (UPDATED WITH GENERIC INSTRUCTIONS) -------------------
async function runPracticeBlock() {
    state.currentBlock = 'Practice';
    state.currentTrialInBlock = 0;
    show(`<div class="message-container">
      <h2>Practice Round</h2>
      <p>You will now see a few practice statements that have clear correct answers.</p>
      <p>Remember:</p>
      ${getKeyReminderHTML()}
      <p>Place your fingers on the keys now.</p>
      <p>Press SPACE to begin.</p>
    </div>`);
    await waitKeys([' ']);

    if (state.practiceStimuli.length === 0) {
        show(`<div class="message-container"><p class="error-text">No practice stimuli available. Please check configuration.</p></div>`);
        return Promise.reject("No practice stimuli defined");
    }
    
    // Run through practice trials with feedback
    for (const stimulus of state.practiceStimuli) {
        // Show the stimulus
        state.trialCountOverall++;
        state.currentTrialInBlock++;
        
        // 1. Fixation Cross
        show(`<div class="fixation-cross-container">+</div>`);
        await sleep(CONFIG.fixationCrossDuration);

        // 2. Statement Display with updated key reminder
        show(`
          <div class="stimulus-container">
            <p class="stimulus-text">${stimulus.statement_text}</p> 
            ${getKeyReminderHTML()}
          </div>
        `);
        
        rtClock = performance.now();

        // 3. Get Response (now using q and p keys)
        const responseResult = await waitKeysOrTimeout([CONFIG.responseKeys.true_key, CONFIG.responseKeys.false_key], CONFIG.statementTimeoutDuration);
        const rt = responseResult.timedOut ? CONFIG.statementTimeoutDuration : Math.round(performance.now() - rtClock);
        
        let participantResponse = null;
        let accuracy = null;

        if (responseResult.timedOut) {
          participantResponse = 'TIMEOUT';
          accuracy = null;
          // Show timeout feedback with enhanced warning
          show(`<div class="message-container">
            <h3 class="warning-message">Time's Up!</h3>
            <p>Please try to respond more quickly. You have 15 seconds to make your judgment.</p>
            <p>Remember:</p>
            ${getKeyReminderHTML()}
            <p>Press SPACE to continue.</p>
          </div>`);
        } else {
          participantResponse = responseResult.key === CONFIG.responseKeys.true_key ? 'True' : 'False';
          accuracy = (participantResponse === 'True') === stimulus.truth_value ? 1 : 0;
          
          // Show feedback based on accuracy
          if (accuracy === 1) {
            show(`<div class="message-container">
              <h3>Correct!</h3>
              <p>This statement is ${stimulus.truth_value ? 'TRUE' : 'FALSE'}.</p>
              <p>Remember:</p>
              ${getKeyReminderHTML()}
              <p>Press SPACE to continue.</p>
            </div>`);
          } else {
            show(`<div class="message-container">
              <h3>Incorrect</h3>
              <p>This statement is actually ${stimulus.truth_value ? 'TRUE' : 'FALSE'}.</p>
              <p>Remember:</p>
              ${getKeyReminderHTML()}
              <p>Press SPACE to continue.</p>
            </div>`);
          }
        }

        // 4. Log Data (now with key assignment)
        const trialData = {
          prolific_id: state.prolificID,
          political_orientation: state.politicalOrientation,
          participant_headline_type: state.participantHeadlineType,
          key_assignment: state.keyAssignment,
          trial_number_overall: state.trialCountOverall,
          block_type: state.currentBlock,
          trial_number_in_block: state.currentTrialInBlock,
          statement_id: stimulus.statement_id,
          statement_text: stimulus.statement_text, 
          headline_type: 'Practice',
          truth_value_stimulus: stimulus.truth_value ? 'TRUE' : 'FALSE', 
          partisan_alignment_stimulus: stimulus.partisan_alignment,
          partisan_congruence: stimulus.partisan_congruence || 'N/A', 
          is_practice_trial: 1,
          is_attention_check: stimulus.is_attention_check ? 1 : 0, 
          response: participantResponse,
          accuracy: accuracy,
          rt_ms: rt,
          avg_favorability: stimulus.avg_favorability || '',
        };
        log(trialData);

        // Wait for space to continue
        await waitKeys([' ']);
        
        // 5. Inter-Trial Interval (ITI)
        show(''); 
        const itiDuration = getRandomInt(CONFIG.itiMinDuration, CONFIG.itiMaxDuration);
        await sleep(itiDuration);
    }

    show(`<div class="message-container">
      <h2>Practice Complete!</h2>
      <p>Now you will move on to the main task.</p>
      <p>Remember:</p>
      ${getKeyReminderHTML()}
      <button id="startMainBtn">Continue to main experiment</button>
    </div>`);
    return new Promise(resolve => {
        document.getElementById('startMainBtn').onclick = resolve;
    });
}

async function runMainExperimentBlock() {
    state.currentBlock = 'MainExperiment';
    state.currentTrialInBlock = 0;
    show(`<div class="message-container">
      <h2>Main Experiment</h2>
      <p>The main experiment will now begin. Answer as <strong>quickly</strong> and as <strong>accurately</strong> as possible.</p>
      <p>You have 15 seconds to respond to each statement.</p>
      <p>Remember:</p>
      ${getKeyReminderHTML()}
      <p>Answer as <strong>quickly</strong> and as <strong>accurately</strong> as possible<p>
      <p>Press SPACE to begin.</p>
    </div>`);
    await waitKeys([' ']);
    
    if (state.mainExperimentStimuli.length === 0) {
        show(`<div class="message-container"><p class="error-text">No main experiment stimuli available for the assigned headline type. Please check configuration and CSV processing.</p></div>`);
        return Promise.reject("No main stimuli available");
    }
    
    for (let i = 0; i < state.mainExperimentStimuli.length; i++) {
        const stimulus = state.mainExperimentStimuli[i];
        await runSingleTrial(stimulus, false);

        if ((i + 1) < state.mainExperimentStimuli.length && (i + 1) % CONFIG.trialsPerBreak === 0) {
            // Break message without progress tracking
            show(`<div class="message-container">
              <h2>Break Time!</h2>
              <p>Please take a short break. Press SPACE when you are ready to continue.</p>
              <p>Remember:</p>
              ${getKeyReminderHTML()}
            </div>`);
            await waitKeys([' ']);
            show(`<div class="fixation-cross-container">+</div>`); 
            await sleep(1000); 
        }
    }
}

// ------------------- DEBRIEFING SCREEN (MODIFIED WITH PROLIFIC REDIRECT) -------------------
async function showDebriefing() {
  // Determine which debriefing file to load based on participant's condition
  const debriefFile = state.participantHeadlineType === 'Clickbait' ? 'debrief_clickbait.txt' : 'debrief_headline.txt';
  const debriefPDF = state.participantHeadlineType === 'Clickbait' ? 'debrief_clickbait.pdf' : 'debrief_headline.pdf';
  
  // Default debriefing text in case the file cannot be loaded
  let defaultDebriefHTML = `
    <h2>Debriefing Statement</h2>
    <p>Thank you for participating in our study on truth judgments of political headlines.</p>
    <p>In this study, we were investigating how different presentation formats of the same information might influence people's judgments of truthfulness.</p>
    <p>We presented you with headlines in a ${state.participantHeadlineType === 'Clickbait' ? 'clickbait' : 'straightforward news'} format to understand how this presentation style affects truth judgments.</p>
    <p>Your data will help us better understand how information presentation influences belief formation and can inform strategies to combat misinformation.</p>
    <p>If you have any questions about this research, please contact the research team.</p>
  `;
  
  try {
    // Try to load the appropriate debriefing file
    const response = await fetch(debriefFile);
    if (response.ok) {
      // If file loaded successfully, use its content
      const debriefContent = await response.text();
      
      show(`
        <div class="info-container">
          ${debriefContent}
          <div class="button-container">
            <a href="${debriefPDF}" download target="_blank" rel="noopener noreferrer" style="text-decoration: none;"><button>Download Debriefing (PDF)</button></a>
            <a href="fact-checks.txt" download target="_blank" rel="noopener noreferrer" style="text-decoration: none;"><button>Download Fact-Checking Sheet</button></a>
            <button id="finish_btn">Finish</button>
          </div>
        </div>
      `);
    } else {
      // If file couldn't be loaded, use the default text
      console.warn(`Could not load debriefing file: ${debriefFile}`);
      show(`
        <div class="info-container">
          ${defaultDebriefHTML}
          <div class="button-container">
            <a href="fact-checks.txt" download target="_blank" rel="noopener noreferrer" style="text-decoration: none;"><button>Download Fact-Checking Sheet</button></a>
            <button id="finish_btn">Finish</button>
          </div>
        </div>
      `);
    }
  } catch (e) {
    // If there was an error loading the file, use the default text
    console.error(`Error loading debriefing file: ${e.message}`);
    show(`
      <div class="info-container">
        ${defaultDebriefHTML}
        <div class="button-container">
          <a href="fact-checks.txt" download target="_blank" rel="noopener noreferrer" style="text-decoration: none;"><button>Download Fact-Checking Sheet</button></a>
          <button id="finish_btn">Finish</button>
        </div>
      </div>
    `);
  }
  
  // Wait for the participant to click finish
  await new Promise(resolve => {
    document.getElementById('finish_btn').onclick = resolve;
  });
  
  // Final thank you message with Prolific redirect arrow
  show(`
    <div class="message-container">
      <h2>Thank You!</h2>
      <p>Your participation is complete.</p>
      <p>Click the arrow below to complete the study and return to Prolific:</p>
      <button class="completion-arrow" id="completion_arrow">→</button>
    </div>
  `);
  
  // Set up the completion arrow to redirect to Prolific with completion code
  document.getElementById('completion_arrow').onclick = () => {
    window.location.href = CONFIG.prolificCompletionURL;
  };
}

// FIXED: Improved finishExperiment function with better error handling
function finishExperiment(){ 
  const csv = toCSV(state.data);
  const filename = `${CONFIG.experimentName.replace(/\s+/g, '_')}_${state.prolificID}_${state.participantHeadlineType}_${new Date().toISOString().slice(0,10)}.csv`;
  
  show('<div class="message-container"><h2>Uploading your data…</h2><p>Please wait. Do not close this window.</p></div>');
  
  // Only log data size, not the entire dataset
  console.log(`Preparing to upload data (${new Blob([csv]).size} bytes)`);
  
  // Try to upload data with improved error handling
  uploadCSV(filename, csv)
    .then(response => {
      console.log("Upload response status:", response.status, response.statusText);
      
      // FIXED: Simplified error handling
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} ${response.statusText}`);
      }
      return response.json();
    })
    .then(result => {
      console.log('Upload successful:', result);
      // After successful data upload, show the debriefing
      showDebriefing();
    })
    .catch(err => {
      console.error('Data upload failed:', err);
      if (CONFIG.fallbackDownload) {
        show(`<div class="message-container">
                <h2>Data Upload Error</h2>
                <p class="error-text">There was an error uploading your data. 
                A CSV file of your data will be downloaded to your computer instead.</p>
                <p><b>Please ensure you send this downloaded file ('${filename}') to the researcher.</b></p>
                <p>Click the button below if the download doesn't start automatically.</p>
                <button id="manualDownloadBtn">Download Data Manually</button>
                <button id="continue_to_debrief">Continue to Debriefing</button>
              </div>`);
        document.getElementById('manualDownloadBtn').onclick = () => downloadCSV(csv, filename);
        document.getElementById('continue_to_debrief').onclick = () => showDebriefing();
        downloadCSV(csv, filename); 
      } else {
        show(`<div class="message-container">
                <h2>Critical Error</h2>
                <p class="error-text">Sorry, your data could not be saved due to a network error, and local download is disabled.</p>
                <p>Please take a screenshot of this page (including any console errors if possible - Ctrl+Shift+J or Cmd+Opt+J) and contact the researcher.</p>
                <p>Error details: ${err.message}</p>
                <button id="continue_to_debrief">Continue to Debriefing</button>
              </div>`);
        document.getElementById('continue_to_debrief').onclick = () => showDebriefing();
      }
    });
}

// ------------------- LAUNCH -------------------
(async () => {
  try {
    show('<h2>Loading experiment configuration...</h2>');
    await loadCSVStimuli(); 
    
    // First show information sheet and get consent
    const consentGiven = await showInformationAndConsent();
    if (!consentGiven) {
      // Stop the experiment if consent was not given
      return;
    }
    
    // Then collect Prolific ID
    await introScreen();
    
    // Then collect demographics and political orientation questionnaire
    await runDemographics();
    
    show('<h2>Preparing experiment trials...</h2>');
    prepareExperimentTrials();
    
    await showInstructionsScreen();
    await runPracticeBlock();
    await runMainExperimentBlock();
    
    finishExperiment();

  } catch (e) {
    console.error("Experiment Error:", e);
    stage.innerHTML = `
        <div class="message-container">
            <h2 style="color:red;">An Error Occurred</h2>
            <p class="error-text">Unfortunately, the experiment encountered a problem and cannot continue.</p>
            <p><b>Error message:</b> ${e.message}</p>
            <p>Please copy this error message, and any details from the browser console (Ctrl+Shift+J or Cmd+Opt+J) and contact the researcher.</p>
            <pre style="text-align:left; background-color:#333; padding:10px; border-radius:5px; max-height:200px; overflow-y:auto;">${e.stack || ''}</pre>
        </div>`;
  }
})();
</script>
</body>
</html>
